// There-Beats, Junior Design Project (ECE 3872)
// Based on code auto-generated by Proteus Visual Designer for Arduino

#pragma GCC push_options
#pragma GCC optimize ("Os")

#include <core.h> // Required by cpu
#include <cpu.h>
#include <Generic.h>
#include <motor_shield_v1.h>
#include <Servo.h> // Required by M1
#include <Generic/GenericServo.h>

#pragma GCC pop_options

////////////////////////////////
// Constants
////////////////////////////////
#define BUZZER_PIN 2 // used by peripheral constructor and directly by cpu.tone
#define RECORDING_MAX_LEN 40
const float noteFreqs[] =
   {110.0f, 123.471f, 130.813f, 146.832f, 164.814f, 174.614f, 195.998f, 207.652f};

////////////////////////////////
// Peripheral Constructors
////////////////////////////////
CPU &cpu = Cpu;
GenericButton resetButton = GenericButton(4);
// NOTE: DC motor significantly slowing simulation, so only using servo for sim demo
// DCMotorV1 motorDC = DCMotorV1(7, 5, 8);
GenericServo motorServo = GenericServo();
GenericRgbLedCc rgbLed = GenericRgbLedCc(11, 12, 13);
GenericRotaryAngleSensor modeRotary = GenericRotaryAngleSensor(A2, 300);
GenericRotaryAngleSensor distanceRotary = GenericRotaryAngleSensor(A3, 300);
GenericBuzzer buzzer = GenericBuzzer(BUZZER_PIN);

void peripheral_setup() {
   // motorDC.begin();
   motorServo.begin(6, 0.001, 0.002);
}

////////////////////////////////
// Global variables
////////////////////////////////
enum State {
   IDLE,
   RECORD,
   PLAY_LIVE,
   PLAY_RECORD
} state = IDLE; // State machine

int recording[RECORDING_MAX_LEN]; // Memory for recording up to 40 half-second notes
int recordingLen = 0; // Length of the recording. Used for appending to end during recording
int playbackIndx = 0; // Current index in recording array for playback

int resetButtonCounter = 0; // Counts how long reset button is pressed

// bool needReloadMotor = false; // Whether DC motor needs to be spun back up to reload position

////////////////////////////////
// Helper function declarations
////////////////////////////////

/// State handlers:
// On recording reset (button pressed 3 sec)
void reset_recording();
// Changes to specified state and runs one-time setup for state
void enter_idle();
void enter_record();
void enter_play_live();
void enter_play_record();
// On every loop while in a state
void loop_idle();
void loop_record();
void loop_play_live();
void loop_play_record();

/// IO Modules:

// Returns the note to be played according to the input (distance) sensor.
// -1 = none, 0-7 = A2,B2,C3,D3,E3,F3,G3,G#3
int read_input_note();
// Plays the specified note on the speaker for a 0.5s duration.
void play_note(int note);
// Moves motors in a manner corresponding to the played note.
void move_for_note(int note);

////////////////////////////////
// Entry Points
////////////////////////////////
void setup () {
   peripheral_setup();
   enter_idle();
}

// Main loop method manages state changes and calls current state handlers.
// During normal execution, runs twice a second.
void loop () {
   // Use mode selection dial to set current state
   int pot = modeRotary.readAngle(); // potentiometer value ranging 0 to 300
   if (pot < 75) {
      if (state != State::IDLE) enter_idle();
   } else if (pot < 150) {
      if (state != State::RECORD) enter_record();
   } else if (pot < 225) {
      if (state != State::PLAY_LIVE) enter_play_live();
   } else {
      if (state != State::PLAY_RECORD) enter_play_record();
   }
      
   // Reset button takes precedence over mode selection dial
   // (i.e. we always enter idle for at least one iteration on a reset)
   if (resetButton()) {
      // If reset button was pressed for 3 seconds (counted every 0.5s)
      if (resetButtonCounter >= 5) {
         reset_recording();
         enter_idle();
         resetButtonCounter = 0;
      } else {
         resetButtonCounter++;
      }
   } else {
      resetButtonCounter = 0;
   }
   
   // Run state loop handler for current state
   switch (state) {
      case State::IDLE:
         loop_idle();
	      break;
      case State::RECORD:
         loop_record();
         break;
      case State::PLAY_LIVE:
         loop_play_live();
         break;
      case State::PLAY_RECORD:
         loop_play_record();
         break;
   }

   // Waits total of half a second, to maintain a 2Hz rate for note playing / recording.
   delay(500);
   // // Half-way through delay, sends reverse command to DC motor if it needs to reload.
   // delay(250);
   // if (needReloadMotor) {
   //    motorDC.run(1, 200);
   //    needReloadMotor = false;
   // }
   // delay(250);
   // motorDC.stop(); // DC motor should always start off stopped
}

////////////////////////////////
// Helper function definitions
////////////////////////////////

void reset_recording() {
   // 'reset' recording by zeroing the length. Array will still
   // have old values but they will be unused / overwritten.
   recordingLen = 0;

   // Flashes LED three times to indicate successful reset
   for (int i = 0; i < 3; i++) {
      rgbLed.set(255, 255, 255);
      delay(150);
      rgbLed.set(0, 0, 0);
      delay(150);
   }
}

void enter_idle() {
   state = State::IDLE;

   // Blue LED when idling
   rgbLed.set(0, 0, 255);
   // Turn off motor
   move_for_note(-1);
   // Turn off speaker
   buzzer.off();
   play_note(-1);
}

void enter_record() {
   state = State::RECORD;

   // Red LED when recording (blinking?)
   rgbLed.set(255, 0, 0);
   // Turn off motor
   move_for_note(-1);
   // Turn on sound
   buzzer.on();
}

void enter_play_live() {
   state = State::PLAY_LIVE;

   // Yellow LED when playing live?
   rgbLed.set(255, 255, 0);
   // Turn on sound
   buzzer.on();
}

void enter_play_record() {
   state = State::PLAY_RECORD;

   // Green LED when playing recording
   rgbLed.set(0, 255, 0);
   // Turn on sound
   buzzer.on();
   // Reset playback index for recording array
   playbackIndx = 0;
}

void loop_idle() {}

void loop_record() {
   // Read input sensor and play note
   int note = read_input_note();
   play_note(note);
   // Save note into recording, appending to the end of the array
   // if we haven't exceeded maximum length
   if (recordingLen < RECORDING_MAX_LEN) {
      recording[recordingLen] = note;
      recordingLen++;
   } else {
      // If exceeded maximum duration, indicate with dark LED
      rgbLed.set(0, 0, 0);
   }
}

void loop_play_live() {
   // Read input sensor, play note and move motors to the note
   int note = read_input_note();
   play_note(note);
   move_for_note(note);
}

void loop_play_record() {
   // Play note from recording array, if length is non-zero
   if (recordingLen > 0) {
      playbackIndx = playbackIndx % recordingLen; // playback loops
      int note = recording[playbackIndx];
      playbackIndx++;
      play_note(note);

      // Move motor to note
      move_for_note(note);
   } else {
      play_note(-1);
   }
}

int read_input_note() {
   int rawIn = analogRead(A3); // analog reading of distance sensor, from 0 to 1023
   int note;
   if (rawIn == 0 || rawIn == 1023) // if min/max reading, interpret as no note
      note = -1;
   else
      note = rawIn / 128; // divide range of values equally into intervals of 1024/8=128
   return note;
}

void play_note(int note) {
   if (note < 0 || note > 7)
      cpu.noTone(BUZZER_PIN);
   else
      cpu.tone(BUZZER_PIN, noteFreqs[note], 500);
}

void move_for_note(int note) {
   if (note < 0 || note > 7) {
      motorServo.write(0);
      // motorDC.stop();
   } else {
      motorServo.write((note + 1) * 22.5); // divide range of motion equally into intervals of 180/8=22.5
      // // Spin DC motor down to hit drum
      // motorDC.run(0, 200);
      // needReloadMotor = true;
   }
}